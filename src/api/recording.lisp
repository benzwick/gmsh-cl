;;;; recording.lisp — CL script recording and .geo→CL translation

(in-package :gmsh)

;;; ---------------------------------------------------------------------------
;;; API call recording
;;; ---------------------------------------------------------------------------

(defvar *recording-stream* nil
  "When non-nil, a stream to which CL API calls are written.")

(defvar *recording-active* nil
  "When non-nil, API calls are being recorded.")

(defmacro with-recording ((filename) &body body)
  "Record all gmsh API calls made during BODY to FILENAME as reproducible CL code."
  `(with-open-file (*recording-stream* ,filename
                                       :direction :output
                                       :if-exists :supersede)
     (let ((*recording-active* t))
       (format *recording-stream* ";;; Recorded gmsh-cl session~%")
       (format *recording-stream* ";;; Generated by with-recording~%~%")
       ,@body)))

(defun record-call (package-name function-name &rest args)
  "Record an API call to the recording stream if recording is active."
  (when (and *recording-active* *recording-stream*)
    (format *recording-stream* "(~A:~A~{ ~S~})~%"
            package-name function-name args)))

;;; ---------------------------------------------------------------------------
;;; .geo → CL translation
;;; ---------------------------------------------------------------------------

(defun translate-geo-line (line)
  "Translate a single .geo command line to a CL form string.
   Returns nil if the line cannot be translated."
  (let ((trimmed (string-trim '(#\Space #\Tab #\; #\Newline #\Return) line)))
    (cond
      ;; Point(tag) = {x, y, z, size};
      ((and (>= (length trimmed) 6)
            (string= (subseq trimmed 0 6) "Point("))
       (let* ((paren-end (position #\) trimmed))
              (tag (subseq trimmed 6 paren-end))
              (brace-start (position #\{ trimmed))
              (brace-end (position #\} trimmed))
              (vals (split-comma (subseq trimmed (1+ brace-start) brace-end))))
         (if (>= (length vals) 3)
             (format nil "(geo:point ~A ~A ~A :mesh-size ~A :tag ~A)"
                     (nth 0 vals) (nth 1 vals) (nth 2 vals)
                     (if (>= (length vals) 4) (nth 3 vals) "0")
                     tag)
             nil)))
      ;; Line(tag) = {start, end};
      ((and (>= (length trimmed) 5)
            (string= (subseq trimmed 0 5) "Line("))
       (let* ((paren-end (position #\) trimmed))
              (tag (subseq trimmed 5 paren-end))
              (brace-start (position #\{ trimmed))
              (brace-end (position #\} trimmed))
              (vals (split-comma (subseq trimmed (1+ brace-start) brace-end))))
         (if (>= (length vals) 2)
             (format nil "(geo:line ~A ~A :tag ~A)"
                     (nth 0 vals) (nth 1 vals) tag)
             nil)))
      ;; Curve Loop(tag) = {curves...};
      ((and (>= (length trimmed) 11)
            (string= (subseq trimmed 0 11) "Curve Loop("))
       (let* ((paren-end (position #\) trimmed))
              (tag (subseq trimmed 11 paren-end))
              (brace-start (position #\{ trimmed))
              (brace-end (position #\} trimmed))
              (vals (split-comma (subseq trimmed (1+ brace-start) brace-end))))
         (format nil "(geo:curve-loop '(~{~A~^ ~}) :tag ~A)"
                 vals tag)))
      ;; Plane Surface(tag) = {wires...};
      ((and (>= (length trimmed) 14)
            (string= (subseq trimmed 0 14) "Plane Surface("))
       (let* ((paren-end (position #\) trimmed))
              (tag (subseq trimmed 14 paren-end))
              (brace-start (position #\{ trimmed))
              (brace-end (position #\} trimmed))
              (vals (split-comma (subseq trimmed (1+ brace-start) brace-end))))
         (format nil "(geo:plane-surface '(~{~A~^ ~}) :tag ~A)"
                 vals tag)))
      ;; Comment lines
      ((and (>= (length trimmed) 2)
            (string= (subseq trimmed 0 2) "//"))
       (format nil ";; ~A" (subseq trimmed 2)))
      (t nil))))

(defun split-comma (s)
  "Split string S by commas, trimming whitespace from each part."
  (let ((parts '())
        (start 0))
    (loop for i from 0 below (length s)
          when (char= (char s i) #\,)
            do (push (string-trim '(#\Space #\Tab) (subseq s start i)) parts)
               (setf start (1+ i)))
    (push (string-trim '(#\Space #\Tab) (subseq s start)) parts)
    (nreverse parts)))

(defun translate-geo-file (input-path &optional output-path)
  "Translate a .geo file to CL code. If OUTPUT-PATH is provided,
   write to that file; otherwise return a list of CL form strings."
  (let ((forms '()))
    (with-open-file (in input-path :direction :input)
      (loop for line = (read-line in nil nil)
            while line
            for form = (translate-geo-line line)
            when form
              do (push form forms)))
    (setf forms (nreverse forms))
    (if output-path
        (with-open-file (out output-path :direction :output :if-exists :supersede)
          (format out ";;; Translated from ~A~%~%" input-path)
          (dolist (form forms)
            (format out "~A~%" form)))
        forms)))
