;;; t13.lisp â€” Remeshing an STL file without an underlying CAD model
;;;
;;; Demonstrates discrete surface remeshing: classify-surfaces to detect
;;; features, create-geometry for parametrization, and remeshing with a
;;; custom MathEval size field.
;;;
;;; Key API: mesh:classify-surfaces, mesh:create-geometry, mesh:field-add
;;;
;;; Equivalent Python: gmsh/tutorials/python/t13.py

;; Create ONELAB parameters with remeshing options:
(onelab:set "[
  {
    \"type\":\"number\",
    \"name\":\"Parameters/Angle for surface detection\",
    \"values\":[40],
    \"min\":20,
    \"max\":120,
    \"step\":1
  },
  {
    \"type\":\"number\",
    \"name\":\"Parameters/Create surfaces guaranteed to be parametrizable\",
    \"values\":[0],
    \"choices\":[0, 1]
  },
  {
    \"type\":\"number\",
    \"name\":\"Parameters/Apply funny mesh size field?\",
    \"values\":[0],
    \"choices\":[0, 1]
  }
]")

;; Clear all models and merge an STL mesh that we would like to remesh:
(gmsh:clear)
(gmsh:merge (namestring (merge-pathnames "_reference/gmsh/tutorials/t13_data.stl"
                                          (asdf:system-source-directory :gmsh-cl))))

;; We first classify ("color") the surfaces by splitting the original surface
;; along sharp geometrical features. This will create new discrete surfaces,
;; curves and points.

;; Angle between two triangles above which an edge is considered as sharp,
;; retrieved from the ONELAB database (see below):
(let* ((angle (first (onelab:get-number "Parameters/Angle for surface detection")))

       ;; For complex geometries, patches can be too complex, too elongated or too
       ;; large to be parametrized; setting the following option will force the
       ;; creation of patches that are amenable to reparametrization:
       (force-parametrizable-patches
         (first (onelab:get-number
                 "Parameters/Create surfaces guaranteed to be parametrizable")))

       ;; For open surfaces include the boundary edges in the classification
       ;; process:
       (include-boundary t)

       ;; Force curves to be split on given angle:
       (curve-angle 180))

  (mesh:classify-surfaces (* angle (/ pi 180.0))
                           :boundary include-boundary
                           :for-reparametrization force-parametrizable-patches
                           :curve-angle (* curve-angle (/ pi 180.0)))

  ;; Create a geometry for all the discrete curves and surfaces in the mesh, by
  ;; computing a parametrization for each one
  (mesh:create-geometry)

  ;; Note that if a CAD model (e.g. as a STEP file, see t20.lisp) is available
  ;; instead of an STL mesh, it is usually better to use that CAD model instead
  ;; of the geometry created by reparametrizing the mesh. Indeed, CAD geometries
  ;; will in general be more accurate, with smoother parametrizations, and will
  ;; lead to more efficient and higher quality meshing. Discrete surface
  ;; remeshing in Gmsh is optimized to handle dense STL meshes coming from e.g.
  ;; imaging systems, where no CAD is available; it is less well suited for the
  ;; poor quality STL triangulations (optimized for size, with e.g. very
  ;; elongated triangles) that are usually generated by CAD tools for e.g. 3D
  ;; printing.

  ;; Create a volume from all the surfaces
  (let* ((s (gmsh:get-entities :dim 2))
         (l (geo:surface-loop (mapcar #'cdr s)))
         (apply-funny-field
           (first (onelab:get-number "Parameters/Apply funny mesh size field?"))))
    (geo:volume (list l))

    (geo:synchronize)

    ;; We specify element sizes imposed by a size field, just because we can :-)
    (let ((f (mesh:field-add "MathEval")))
      (if (not (zerop apply-funny-field))
          (mesh:field-set-string f "F" "2*Sin((x+y)/5) + 3")
          (mesh:field-set-string f "F" "4"))
      (mesh:field-set-as-background-mesh f))))

(mesh:generate :dim 3)
;; (gmsh:write "/tmp/t13.msh")
